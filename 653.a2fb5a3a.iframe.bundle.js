"use strict";(self.webpackChunkreact_treema=self.webpackChunkreact_treema||[]).push([[653],{"./src/Treema/TreemaRoot.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{W:()=>TreemaRoot});var react=__webpack_require__("./node_modules/react/index.js"),utils=__webpack_require__("./src/Treema/utils.ts");const selectPath=path=>({type:"select_path_action",path}),navigateUp=skipAddProperties=>({type:"navigate_up_action",skipAddProperties}),navigateDown=skipAddProperties=>({type:"navigate_down_action",skipAddProperties}),setPathClosed=(path,closed)=>({type:"set_path_closed_action",path,closed}),beginEdit=path=>({type:"begin_edit_action",path}),setData=(path,data)=>({type:"set_data_action",data,path}),endAddProperty=cancel=>({type:"end_add_property_action",cancel:cancel||!1});var es=__webpack_require__("./node_modules/reselect/es/index.js");const getData=state=>state.data,getRootSchema=state=>state.rootSchema,getSchemaLib=state=>state.schemaLib,getLastSelectedPath=state=>state.lastSelected||"",getWorkingSchemaChoices=state=>state.workingSchemaChoices,getAllDatasAndSchemas=(0,es.P1)([getData,getRootSchema,getSchemaLib,getWorkingSchemaChoices],((data,rootSchema,schemaLib,workingSchemaChoices)=>{const datasAndSchemas={},defaultsToWalk=[];(0,utils._p)(data,rootSchema,schemaLib,(({path,data,schema,possibleSchemas})=>(datasAndSchemas[path]={data,schema:void 0!==workingSchemaChoices[path]?possibleSchemas[workingSchemaChoices[path]]:schema,possibleSchemas:possibleSchemas||[],defaultRoot:!1},"object"===schema.type&&"object"===(0,utils.oL)(schema.default)&&defaultsToWalk.push(path),datasAndSchemas[path].schema)));const extantKeys=new Set(Object.keys(datasAndSchemas));for(;defaultsToWalk.length;){const defaultRootPath=defaultsToWalk.shift(),pathInfos=datasAndSchemas[defaultRootPath];(0,utils._p)(pathInfos.schema.default,pathInfos.schema,schemaLib,(({path,data,schema,possibleSchemas})=>{const fullPath=defaultRootPath?(0,utils._V)(defaultRootPath,path):path;if(""===path)return;if(schema.default&&defaultsToWalk.push(fullPath),void 0!==datasAndSchemas[fullPath])return datasAndSchemas[fullPath].schema.default??={},void Object.assign(datasAndSchemas[fullPath].schema.default,data);const defaultRoot=extantKeys.has((0,utils.VK)(fullPath));datasAndSchemas[fullPath]={data,schema,possibleSchemas:possibleSchemas||[],defaultRoot}}))}return datasAndSchemas})),getWorkingSchema=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas],((path,datasAndSchemas)=>datasAndSchemas[path].schema)),getWorkingSchemas=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas],((path,datasAndSchemas)=>datasAndSchemas[path].possibleSchemas)),getEffectiveWorkingSchemaChoices=(0,es.P1)([getAllDatasAndSchemas,getWorkingSchemaChoices],((datasAndSchemas,workingSchemaChoices)=>{const effectiveWorkingSchemaChoices={};return Object.keys(datasAndSchemas).forEach((path=>{const{schema,possibleSchemas}=datasAndSchemas[path];if(1===possibleSchemas.length)return;const index=possibleSchemas.indexOf(schema);effectiveWorkingSchemaChoices[path]=index})),Object.assign({},effectiveWorkingSchemaChoices,workingSchemaChoices)})),getDataAtPath=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas],((path,datasAndSchemas)=>datasAndSchemas[path].data)),getIsDefaultRoot=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas],((path,datasAndSchemas)=>datasAndSchemas[path].defaultRoot)),getPropertiesAvailableAtPath=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas],((path,datasAndSchemas)=>{const{schema,data}=datasAndSchemas[path];return _getPropertiesAvailable(data,schema)})),_getPropertiesAvailable=(data,schema)=>{if(!schema.properties)return[];const properties=[];for(const key of Object.keys(schema.properties)){const childSchema=schema.properties[key];void 0===data[key]&&("hidden"!==childSchema.format&&(childSchema.readOnly||properties.push({key,title:childSchema.title||key})))}return properties.sort(),properties},hasChildrenAtPath=(0,es.P1)([state=>getAllDatasAndSchemas(state),(_,path)=>path],((datasAndSchemas,path)=>{const{data}=datasAndSchemas[path];return["array","object"].includes((0,utils.oL)(data))})),canAddChildAtPath=(0,es.P1)([state=>getAllDatasAndSchemas(state),(_,path)=>path],((datasAndSchemas,path)=>{const{data,schema}=datasAndSchemas[path];return _canAddChild(data,schema)})),_canAddChild=(data,schema)=>{if(schema.readOnly)return!1;const dataType=(0,utils.oL)(data);if("array"===dataType)return!(schema.maxItems&&schema.maxItems<=data.length);if("object"===dataType){return!(0===_getPropertiesAvailable(data,schema).length&&!1===schema.additionalProperties&&!schema.patternProperties)}return!1},getSchemaErrors=(0,es.P1)([getData,getRootSchema,getSchemaLib],((data,rootSchema,schemaLib)=>schemaLib.validateMultiple(data,rootSchema).errors)),getSchemaErrorsByPath=(0,es.P1)([getSchemaErrors,getAllDatasAndSchemas,getSchemaLib],((errors,datasAndSchemas,schemaLib)=>{const errorsByPath={};return errors.forEach((error=>{const data=datasAndSchemas[error.dataPath].data,workingSchema=datasAndSchemas[error.dataPath].schema,workingErrors=schemaLib.validateMultiple(data,workingSchema).errors||[];for(let workingError of workingErrors){const absPath=error.dataPath+workingError.dataPath;errorsByPath[absPath]||(errorsByPath[absPath]=[]);const newError={...workingError,dataPath:absPath};let exists=!1;for(let existingError of errorsByPath[absPath])if(JSON.stringify(newError)===JSON.stringify(existingError)){exists=!0;break}exists||errorsByPath[absPath].push(newError)}})),errorsByPath})),getDefinitionAtPath=(0,es.P1)([(_,path)=>path,getAllDatasAndSchemas,state=>state.definitions],((path,datasAndSchemas,definitions)=>{const{schema,data}=datasAndSchemas[path];if(schema.enum&&definitions.enum)return definitions.enum;const dataType=(0,utils.oL)(data);return dataType!==schema.type?definitions[dataType]:schema.$id&&definitions[schema.$id]?definitions[schema.$id]:definitions[schema.format||""]||definitions[schema.type]})),canEditPathDirectly=(0,es.P1)([(state,path)=>getDefinitionAtPath(state,path)],(definition=>!!definition.Edit)),isInsertPropertyPlaceholder=path=>0===path.indexOf("addTo:"),normalizeToPath=path=>isInsertPropertyPlaceholder(path)?path.slice(6):path,getOrderInfo=(0,es.P1)([getAllDatasAndSchemas],(datasAndSchemas=>{const pathList=[];let stack=[""];const pathToChildren={};for(;stack.length;){const path=stack.shift();if(isInsertPropertyPlaceholder(path)){pathList.push(path);continue}const{data,schema}=datasAndSchemas[path];if("hidden"===schema.format)continue;const dataType=(0,utils.oL)(data);if("array"===dataType){const childPaths=data.map(((_,index)=>path+"/"+index));_canAddChild(data,schema)&&stack.unshift("addTo:"+path),stack=childPaths.concat(stack),pathToChildren[path]=childPaths}if("object"===dataType){const keys=[],keysListed=new Set;schema.properties&&Object.keys(schema.properties).forEach((key=>{void 0===data[key]&&void 0===(schema.default||{})[key]||(keys.push(`${path}/${key}`),keysListed.add(key))})),"object"==typeof data&&Object.keys(data).forEach((key=>{keysListed.has(key)||(keys.push(`${path}/${key}`),keysListed.add(key))})),schema.default&&Object.keys(schema.default).forEach((key=>{keysListed.has(key)||(keys.push(`${path}/${key}`),keysListed.add(key))})),_canAddChild(data,schema)&&stack.unshift("addTo:"+path),stack=keys.concat(stack),pathToChildren[path]=keys}pathList.push(path)}return{pathOrder:pathList,pathToChildren}})),getListOfPaths=(0,es.P1)([getOrderInfo],(orderInfo=>orderInfo.pathOrder)),getChildOrderForPath=(0,es.P1)([getOrderInfo,(_,path)=>path],((orderInfo,path)=>orderInfo.pathToChildren[path]||[])),getNextRow=(state,skipAddProperties)=>{let index=0;const paths=getListOfPaths(state);if(0===paths.length)return"";if(void 0===state.lastSelected)index=0;else{const currentIndex=paths.indexOf(state.lastSelected||"");for(index=Math.min(currentIndex+1,paths.length-1);index<paths.length&&(getAnyAncestorsClosed(state,paths[index])||skipAddProperties&&isInsertPropertyPlaceholder(paths[index]));)index++;index===paths.length&&(index=currentIndex)}return paths[index]},getPreviousRow=(state,skipAddProperties)=>{let index,nextPath,nextPathParent;const paths=getListOfPaths(state);for(index=void 0===state.lastSelected||0===paths.indexOf(state.lastSelected)?paths.length-1:paths.indexOf(state.lastSelected)-1;index>0&&(getAnyAncestorsClosed(state,paths[index])||skipAddProperties&&isInsertPropertyPlaceholder(paths[index]));)index--;return nextPath=paths[index],nextPathParent=(0,utils.VK)(normalizeToPath(nextPath)),getClosed(state)[nextPathParent]?nextPathParent:nextPath},getClosed=state=>state.closed,getCanClose=(0,es.P1)([getClosed,getAllDatasAndSchemas,(_,path)=>path],((closed,datasAndSchemas,path)=>!closed[path]&&!!["array","object"].includes((0,utils.oL)(datasAndSchemas[path]?.data)))),getCanOpen=(0,es.P1)([getClosed,getAllDatasAndSchemas,(_,path)=>path],((closed,datasAndSchemas,path)=>!!closed[path]&&!!["array","object"].includes((0,utils.oL)(datasAndSchemas[path]?.data)))),getAnyAncestorsClosed=(0,es.P1)([getClosed,(_,path)=>path],((closed,path)=>{let currentPath=(0,utils.VK)(path);for(isInsertPropertyPlaceholder(path)&&(currentPath=normalizeToPath(path));""!==currentPath;){if(closed[currentPath])return!0;currentPath=(0,utils.VK)(currentPath)}return!1}));function reducer(state,action){let paths,index,nextPath;switch(action.type){case"select_path_action":let newState={...state};return delete newState.editing,delete newState.editingData,delete newState.addingProperty,delete newState.addingPropertyKey,void 0===action.path?(delete newState.lastSelected,newState):(newState.lastSelected=action.path,newState);case"navigate_up_action":return{...state,lastSelected:normalizeToPath(getPreviousRow(state,action.skipAddProperties))};case"navigate_down_action":const nextSelected=getNextRow(state,action.skipAddProperties);return{...state,lastSelected:normalizeToPath(nextSelected)};case"navigate_in_action":return paths=getListOfPaths(state).slice(1),index=paths.indexOf(state.lastSelected||""),nextPath=paths[index+1],0===normalizeToPath(nextPath).indexOf(normalizeToPath(paths[index]))?{...state,lastSelected:normalizeToPath(nextPath)}:state;case"navigate_out_action":let parentPath=(0,utils.VK)(state.lastSelected||"");return parentPath?{...state,lastSelected:parentPath}:state;case"set_path_closed_action":return{...state,closed:{...state.closed,[action.path]:action.closed}};case"set_data_action":return""===action.path?{...state,data:action.data,workingSchemaChoices:{}}:{...state,data:setDataAtPath(state,action.path,action.data),workingSchemaChoices:getEffectiveWorkingSchemaChoices(state)};case"begin_edit_action":const path=action.path||normalizeToPath(state.lastSelected||"");if(!path)return state;if(!canEditPathDirectly(state,path))return state;const initialData=getAllDatasAndSchemas(state)[path].data;return{...state,editing:path,editingData:initialData,lastSelected:path};case"edit_value_action":return{...state,editingData:action.newValue};case"end_editing_action":return{...state,editing:void 0};case"begin_add_property_action":let p=action.path;return isInsertPropertyPlaceholder(action.path)||(p="addTo:"+action.path),{...state,addingProperty:!0,lastSelected:p,addingPropertyKey:""};case"edit_add_property_action":return{...state,addingPropertyKey:action.keyToAdd};case"end_add_property_action":if(void 0===state.addingPropertyKey||void 0===state.addingProperty||action.cancel||!state.lastSelected)return{...state,addingProperty:void 0,addingPropertyKey:void 0};const parentSchema=getAllDatasAndSchemas(state)[normalizeToPath(state.lastSelected)].schema,childSchema=(0,utils.Fc)(state.addingPropertyKey,parentSchema),workingSchema=(0,utils.Ke)(void 0,(0,utils.zL)(childSchema,state.schemaLib),state.schemaLib);return{...state,addingProperty:!1,data:setDataAtPath(state,(0,utils._V)(normalizeToPath(state.lastSelected),state.addingPropertyKey),(0,utils.AH)(workingSchema.type))};case"delete_action":const parent=(0,utils.VK)(action.path),parentData=getAllDatasAndSchemas(state)[parent].data,newData=(0,utils.d9)(parentData,{shallow:!0}),lastSegment=(0,utils.qD)(action.path).pop();if("array"===(0,utils.oL)(parentData)){const parsedSegment=parseInt(lastSegment);newData.splice(parsedSegment,1)}else delete newData[lastSegment];let previousRow=getPreviousRow(state,!0);previousRow===action.path&&(previousRow="");const s={...state,data:setDataAtPath(state,parent,newData),lastSelected:previousRow},getNextRowResult=getNextRow(s,!0);return s.lastSelected=getNextRowResult,s;case"set_working_schema_action":const workingSchemaChoices=getEffectiveWorkingSchemaChoices(state);workingSchemaChoices[action.path]=action.index;for(let key of Object.keys(workingSchemaChoices))key!==action.path&&0===key.indexOf(action.path)&&delete workingSchemaChoices[key];return{...state,workingSchemaChoices};default:console.error("Unknown action",action)}return state}const setDataAtPath=(state,path,data)=>{if(""===path)return data;const newData=(0,utils.d9)(state.data,{shallow:!0});let currentChildData=state.data,newChildData=newData;const segments=(0,utils.qD)(path),lastSegment=segments.pop();let currentPath="";const datasAndSchemas=getAllDatasAndSchemas(state);return segments.forEach((pathSegment=>{currentPath=(0,utils._V)(currentPath,pathSegment);const parsedSegment="array"===(0,utils.oL)(currentChildData)?parseInt(pathSegment):pathSegment;currentChildData=datasAndSchemas[currentPath].data,newChildData[parsedSegment]=(0,utils.d9)(currentChildData,{shallow:!0}),newChildData=newChildData[parsedSegment]})),newChildData[lastSegment]=data,newData};var Treema_context=__webpack_require__("./src/Treema/context.ts"),injectStylesIntoStyleTag=__webpack_require__("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),injectStylesIntoStyleTag_default=__webpack_require__.n(injectStylesIntoStyleTag),styleDomAPI=__webpack_require__("./node_modules/style-loader/dist/runtime/styleDomAPI.js"),styleDomAPI_default=__webpack_require__.n(styleDomAPI),insertBySelector=__webpack_require__("./node_modules/style-loader/dist/runtime/insertBySelector.js"),insertBySelector_default=__webpack_require__.n(insertBySelector),setAttributesWithoutAttributes=__webpack_require__("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),setAttributesWithoutAttributes_default=__webpack_require__.n(setAttributesWithoutAttributes),insertStyleElement=__webpack_require__("./node_modules/style-loader/dist/runtime/insertStyleElement.js"),insertStyleElement_default=__webpack_require__.n(insertStyleElement),styleTagTransform=__webpack_require__("./node_modules/style-loader/dist/runtime/styleTagTransform.js"),styleTagTransform_default=__webpack_require__.n(styleTagTransform),base=__webpack_require__("./node_modules/css-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/Treema/base.scss"),options={};options.styleTagTransform=styleTagTransform_default(),options.setAttributes=setAttributesWithoutAttributes_default(),options.insert=insertBySelector_default().bind(null,"head"),options.domAPI=styleDomAPI_default(),options.insertStyleElement=insertStyleElement_default();injectStylesIntoStyleTag_default()(base.Z,options);base.Z&&base.Z.locals&&base.Z.locals;const handleAddChild=(path,state,dispatch)=>{const schema=getWorkingSchema(state,path),data=getDataAtPath(state,path);if("object"===schema.type)dispatch((path=>({type:"begin_add_property_action",path}))(path));else if("array"===schema.type){const childSchema=(0,utils.wg)(data.length,schema,state.schemaLib),newData=childSchema.default?(0,utils.d9)(childSchema.default):(0,utils.AH)(childSchema.type),newDataPath=(0,utils._V)(path,data.length);dispatch(setData(newDataPath,newData)),dispatch(selectPath(newDataPath)),dispatch(beginEdit(newDataPath))}},TreemaNode=({path})=>{const context=(0,react.useContext)(Treema_context.n),{dispatch,state,editRefs}=context,data=getDataAtPath(state,path),isOpen=!getClosed(state)[path],isEditing=state.editing===path,workingSchema=getWorkingSchema(state,path),workingSchemas=getWorkingSchemas(state,path),workingSchemaIndex=workingSchemas.indexOf(workingSchema),parentIsArray=path&&"array"===getWorkingSchema(state,(0,utils.VK)(path)).type,isRoot=""===path;let name=workingSchema.title;const definition=getDefinitionAtPath(state,path),canOpen=hasChildrenAtPath(state,path),description=workingSchema.description,childrenKeys=getChildOrderForPath(state,path)||[],isSelected=state.lastSelected===path,errors=getSchemaErrorsByPath(state)[path]||[],togglePlaceholder=`${isOpen?"Close":"Open"} ${path}`,isDefaultRoot=getIsDefaultRoot(state,path),isAddingProperty="addTo:"+path===state.lastSelected&&state.addingProperty,isFocusedOnAddProperty="addTo:"+path===state.lastSelected&&!state.addingProperty;void 0===name&&(isRoot?name="(Document Root)":parentIsArray||(name=(0,utils.Tq)(path||"")));const onSelect=(0,react.useCallback)((e=>{isEditing?e.stopPropagation():(state.editing&&state.lastSelected&&(dispatch(setData(state.lastSelected,state.editingData)),dispatch({type:"end_editing_action"})),e.stopPropagation(),dispatch(selectPath(path||"")))}),[dispatch,path,state.editing,state.editingData,state.lastSelected,isEditing]),onToggle=(0,react.useCallback)((e=>{e.stopPropagation(),dispatch(setPathClosed(path,isOpen))}),[isOpen,path,dispatch]),onChangeValue=(0,react.useCallback)((val=>{dispatch({type:"edit_value_action",newValue:val})}),[dispatch]),onAddChild=(0,react.useCallback)((e=>{e.stopPropagation(),handleAddChild(path,context.state,context.dispatch)}),[path,context.state,context.dispatch]),onChangeAddProperty=(0,react.useCallback)((val=>{dispatch({type:"edit_add_property_action",keyToAdd:val})}),[dispatch]),onSetWorkingModel=(0,react.useCallback)((val=>{const newIndex=parseInt(val.target.value),newSchema=workingSchemas[newIndex];let newData=(0,utils.d9)(newSchema.default);void 0===newData&&(newData=(0,utils.AH)(newSchema.type)),dispatch(setData(path,newData)),dispatch(((path,index)=>({type:"set_working_schema_action",path,index}))(path,newIndex))}),[dispatch,path,workingSchemas]),displayRef=react.useRef(null),addPropertyRef=react.useRef(null),addPropRef=react.useRef(null);if((0,react.useEffect)((()=>{let focusable=null;isEditing?focusable=editRefs[0]?.current:isAddingProperty?focusable=addPropertyRef.current:isSelected?focusable=displayRef.current:isFocusedOnAddProperty&&(focusable=addPropRef.current),focusable&&focusable.focus&&focusable.focus()})),"hidden"===workingSchema.format)return null;const classNames=["treema-node",isOpen?"treema-open":"treema-closed",isRoot?"treema-root":"",isSelected?"treema-selected":"",errors.length?"treema-has-error":"",isDefaultRoot?"treema-default-stub":"",definition.shortened?"treema-shortened":""],valueClassNames=["treema-value","treema-"+definition.id,isEditing?"treema-edit":"treema-display"];return react.createElement("div",{className:classNames.join(" "),onClick:onSelect},canOpen&&""!==path&&react.createElement("span",{className:"treema-toggle",role:"button",onClick:onToggle,placeholder:togglePlaceholder}),react.createElement("div",{ref:displayRef,tabIndex:-1,className:"treema-row"},workingSchemas.length>1?react.createElement("select",{onChange:onSetWorkingModel,value:workingSchemaIndex,className:"treema-schema-select"},workingSchemas.map(((schema,index)=>react.createElement("option",{key:index,value:index},schema.title||schema.type||"(untitled schema)")))):null,void 0!==name?react.createElement("span",{className:"treema-key",title:description},`${""===name?"(empty string)":name}: `):null,react.createElement("div",{className:valueClassNames.join(" ")},isEditing&&definition.Edit?react.createElement(definition.Edit,{data:state.editingData,schema:workingSchema,onChange:onChangeValue}):react.createElement(definition.Display,{data,schema:workingSchema,path})),errors.length?react.createElement("span",{className:"treema-error"},errors[0].message):null),childrenKeys.length&&canOpen&&isOpen?react.createElement("div",{className:"treema-children"},childrenKeys.map((childPath=>react.createElement(TreemaNode,{key:childPath,path:childPath})))):null,isAddingProperty&&react.createElement(react.Fragment,null,react.createElement("input",{className:"treema-new-prop",type:"text",ref:addPropertyRef,list:"treema-new-prop-datalist",onChange:e=>{onChangeAddProperty(e.target.value)},"data-testid":"treema-new-prop-input"}),react.createElement("datalist",{id:"treema-new-prop-datalist"},getPropertiesAvailableAtPath(state,path).map((prop=>react.createElement("option",{label:prop.title,value:prop.key,key:prop.key}))))),isOpen&&canAddChildAtPath(state,path)&&react.createElement("div",{className:"treema-add-child",onClick:onAddChild,ref:addPropRef,tabIndex:-1},react.createElement("span",null,"+")))};try{TreemaNode.displayName="TreemaNode",TreemaNode.__docgenInfo={description:'For each value within a JSON object, there will be a TreemaNode to represent it.\nTreemaNodes rely heavily on state and selectors to get necessary information, keying\nentirely off the path that is given to it to render.\n\nTreemaNode handles:\n- Rendering the "key" and "value" of the node\n- Rendering an input element if the value is being edited\n- Mouse events\n- Maintaining focus\n- Rendering its children, if the value is an array or object',displayName:"TreemaNode",props:{path:{defaultValue:null,description:"",name:"path",required:!0,type:{name:"string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/Treema/TreemaNode.tsx#TreemaNode"]={docgenInfo:TreemaNode.__docgenInfo,name:"TreemaNode",path:"src/Treema/TreemaNode.tsx#TreemaNode"})}catch(__react_docgen_typescript_loader_error){}const TreemaArrayNodeDefinition={id:"array",shortened:!0,Display:({data,path,schema})=>{const context=(0,react.useContext)(Treema_context.n),{state}=context;if(!data)return react.createElement(react.Fragment,null);if(0===data.length)return schema.title?react.createElement("span",null,"(empty ",schema.title,")"):react.createElement("span",null,"(empty)");const children=data.slice(0,3).map(((child,index)=>{const childPath=(0,utils._V)(path,index.toString()),childWorkingSchema=getWorkingSchema(state,childPath),definition=getDefinitionAtPath(state,childPath);return react.createElement(definition.Display,{data:child,schema:childWorkingSchema,path:childPath,key:childPath})})),joinedChildren=[];return children.forEach(((child,index)=>{joinedChildren.push(child),index<children.length-1&&joinedChildren.push(react.createElement("span",{key:index}," | "))})),react.createElement("span",null,joinedChildren)}};var hooks=__webpack_require__("./src/Treema/definitions/hooks.tsx");const TreemaBooleanNodeDefinition={id:"boolean",Display:props=>{const{data}=props;return react.createElement("span",null,JSON.stringify(data))},Edit:props=>{const{data,onChange}=props,ref=(0,hooks.S)();return react.createElement("span",null,JSON.stringify(data),react.createElement("input",{type:"checkbox",checked:data,ref,onChange:e=>{onChange(e.target.checked)}}))}},TreemaNullNodeDefinition={id:"null",Display:()=>react.createElement("span",null,"null")},TreemaNumberNodeDefinition={id:"number",Display:({data})=>react.createElement("span",null,data),Edit:({data,schema,onChange})=>{const ref=(0,hooks.S)();return react.createElement("input",{value:data,ref,onChange:e=>{onChange(parseFloat(e.target.value))},type:"number",min:schema.minimum||void 0,max:schema.maximum||void 0})}},TreemaObjectNodeDefinition={id:"object",shortened:!0,Display:({data,schema,path})=>{const context=(0,react.useContext)(Treema_context.n),{state}=context;if(!data)return react.createElement(react.Fragment,null);if(schema.displayProperty){const displayValue=data[schema.displayProperty];if(displayValue)return react.createElement("span",null,displayValue)}let children=Object.entries(data).map((([key,value])=>{if(void 0===value)return null;const childPath=(0,utils._V)(path,key),name=getWorkingSchema(state,childPath).title||key;if(["object","array"].includes((0,utils.oL)(value)))return name;let valueStringish="string"===(0,utils.oL)(value)?value:JSON.stringify(value);"undefined"===(0,utils.oL)(value)&&(valueStringish="undefined");let valueString=valueStringish;return valueString.length>20&&(valueString=valueString.slice(0,20)+" ..."),`${name}=${valueString}`})).filter((v=>v));children.length>3&&(children=children.slice(0,3),children.push("..."));const joinedChildren=[];return children.forEach(((child,index)=>{joinedChildren.push(child),index<children.length-1&&joinedChildren.push(", ")})),react.createElement("span",null,joinedChildren.join(""))}},stringInputTypes=["color","date","datetime-local","email","password","tel","text","time","url"],TreemaStringNodeDefinition={id:"string",Display:({data})=>react.createElement("span",null,data),Edit:({data,schema,onChange})=>{const ref=(0,hooks.S)();return react.createElement("input",{value:data,ref,onChange:e=>{onChange(e.target.value)},maxLength:schema.maxLength||void 0,minLength:schema.minLength||void 0,type:schema.format&&stringInputTypes.includes(schema.format)?schema.format:void 0,"data-testid":"treema-edit-string-input"})}},TreemaIntegerNodeDefinition={id:"integer",Display:({data})=>react.createElement("span",null,data),Edit:({data,schema,onChange})=>{const ref=(0,hooks.S)();return react.createElement("input",{value:data,ref,onChange:e=>{onChange(parseInt(e.target.value))},type:"number",min:schema.minimum||void 0,max:schema.maximum||void 0})}},TreemaEnumNodeDefinition={id:"enum",Display:({data})=>react.createElement("span",null,JSON.stringify(data)),Edit:({data,schema,onChange})=>{const ref=(0,hooks.S)();return react.createElement("select",{value:data,ref,onChange:e=>{onChange(e.target.value)},"data-testid":"treema-edit-enum-input"},(schema.enum||[]).map(((value,index)=>react.createElement("option",{key:index,value},value))))}};var core=__webpack_require__("./node_modules/css-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/Treema/definitions/core.scss"),core_options={};core_options.styleTagTransform=styleTagTransform_default(),core_options.setAttributes=setAttributesWithoutAttributes_default(),core_options.insert=insertBySelector_default().bind(null,"head"),core_options.domAPI=styleDomAPI_default(),core_options.insertStyleElement=insertStyleElement_default();injectStylesIntoStyleTag_default()(core.Z,core_options);core.Z&&core.Z.locals&&core.Z.locals;const coreDefinitions=[TreemaObjectNodeDefinition,TreemaArrayNodeDefinition,TreemaStringNodeDefinition,TreemaNumberNodeDefinition,TreemaBooleanNodeDefinition,TreemaNullNodeDefinition,TreemaIntegerNodeDefinition,TreemaEnumNodeDefinition],wrapDefinitions=defs=>{const wrapped={};return defs.forEach((def=>{wrapped[def.id]=def,def.schema?.$id&&(wrapped[def.schema.$id]=def)})),wrapped},TreemaRoot=(wrapDefinitions(coreDefinitions),({data,schema,schemaLib,initOpen,onEvent,definitions})=>{const lib=(0,react.useMemo)((()=>{const lib=schemaLib||(0,utils.cD)();return definitions?.forEach((definition=>{definition.schema&&definition.schema.$id&&lib.addSchema(definition.schema,definition.schema.$id)})),lib}),[definitions,schemaLib]),closed=(0,react.useMemo)((()=>{if(void 0===initOpen)return{};const closed={};return(0,utils._p)(data,schema,lib,(({path})=>{(0,utils.Eu)(path)===initOpen&&(closed[path]=!0)})),closed}),[]),populatedData=(0,react.useMemo)((()=>(0,utils.Ms)(data,schema,lib)),[data,schema,lib]),[state,dispatch]=(0,react.useReducer)(reducer,{data:populatedData,schemaLib:lib,rootSchema:schema,closed,definitions:Object.assign({},wrapDefinitions(coreDefinitions),wrapDefinitions(definitions||[])),settings:{},workingSchemaChoices:{}}),keyboardCallbackRef=(0,react.useRef)(),rootRef=react.useRef(null),onKeyDown=(0,react.useCallback)((event=>{if(!keyboardCallbackRef.current||!1!==keyboardCallbackRef.current(event)){if("ArrowUp"!==event.key||state.editing||state.addingProperty||(event.preventDefault(),dispatch(navigateUp(!0))),"ArrowDown"!==event.key||state.editing||state.addingProperty||(event.preventDefault(),dispatch(navigateDown(!0))),"ArrowLeft"===event.key&&!state.editing&&!state.addingProperty){event.preventDefault();const selectedPath=getLastSelectedPath(state);getCanClose(state,selectedPath)?dispatch(setPathClosed(selectedPath,!0)):dispatch({type:"navigate_out_action"})}if("ArrowRight"===event.key&&!state.editing&&!state.addingProperty){event.preventDefault();const selectedPath=getLastSelectedPath(state);getCanOpen(state,selectedPath)?dispatch(setPathClosed(selectedPath,!1)):dispatch({type:"navigate_in_action"})}if("Escape"===event.key){if(event.preventDefault(),state.editing)return void dispatch({type:"end_editing_action"});if(state.addingProperty)return void dispatch(endAddProperty(!0));dispatch(selectPath(void 0)),rootRef.current?.focus()}if("Enter"===event.key||"Tab"===event.key){event.preventDefault();const tryToEdit="Enter"===event.key;if(state.addingProperty&&state.lastSelected&&state.addingPropertyKey&&(dispatch(endAddProperty()),tryToEdit&&!event.shiftKey))return void dispatch(beginEdit((0,utils._V)(normalizeToPath(state.lastSelected),state.addingPropertyKey)));if(!event.shiftKey&&!state.editing&&state.lastSelected&&!isInsertPropertyPlaceholder(state.lastSelected)&&canEditPathDirectly(state,state.lastSelected)&&tryToEdit)return void dispatch(beginEdit(state.lastSelected));if(!event.shiftKey&&!state.addingProperty&&state.lastSelected&&isInsertPropertyPlaceholder(state.lastSelected)&&tryToEdit)return void handleAddChild(state.lastSelected.slice(6),state,dispatch);state.editing&&state.lastSelected&&(dispatch(setData(state.lastSelected,state.editingData)),dispatch({type:"end_editing_action"})),dispatch(event.shiftKey?navigateUp():navigateDown());const nextSelection=event.shiftKey?getPreviousRow(state):getNextRow(state);tryToEdit?isInsertPropertyPlaceholder(nextSelection)?handleAddChild(nextSelection.slice(6),state,dispatch):nextSelection!==state.lastSelected&&canEditPathDirectly(state,normalizeToPath(nextSelection))&&dispatch(beginEdit()):dispatch(selectPath(nextSelection))}if("Backspace"===event.key&&!state.editing&&!state.addingProperty){if(event.preventDefault(),isInsertPropertyPlaceholder(state.lastSelected||""))return;if(state.lastSelected){let nextSelection=getNextRow(state,!0);nextSelection===state.lastSelected&&(nextSelection=getPreviousRow(state,!0)),dispatch({type:"delete_action",path:state.lastSelected})}}}}),[dispatch,state,keyboardCallbackRef]);(0,react.useEffect)((()=>{rootRef.current?.addEventListener("keydown",onKeyDown);const currentRef=rootRef.current;return()=>{currentRef?.removeEventListener("keydown",onKeyDown)}}),[onKeyDown]);const dataRef=(0,react.useRef)(data);(0,react.useEffect)((()=>{data!==dataRef.current&&(dispatch(setData("",data)),dataRef.current=data)}),[data,dataRef]);const prevLastSelected=(0,react.useRef)(state.lastSelected),prevData=(0,react.useRef)(state.data);(0,react.useEffect)((()=>{onEvent&&(prevLastSelected.current!==state.lastSelected&&onEvent({type:"change_select_event",path:state.lastSelected}),prevData.current!==state.data&&onEvent({type:"change_data_event",data:state.data}))}),[state.lastSelected,state.data,onEvent]);const editRefs=(0,react.useMemo)((()=>[]),[]),context={state,dispatch,keyboardCallbackRef,editRefs};return react.createElement(Treema_context.n.Provider,{value:context},react.createElement("div",{ref:rootRef,"data-testid":"treema-root",tabIndex:-1},react.createElement(TreemaNode,{path:""})))});try{TreemaRoot.displayName="TreemaRoot",TreemaRoot.__docgenInfo={description:"The main entrypoint for any Treema rendered on your site. Provide data and a schema and this component\nwill render that data, and enable edits, according to that schema. You can and probably should also\nprovide a JSON Schema validator library which will thoroughly enforce the schema and provide error messages.",displayName:"TreemaRoot",props:{data:{defaultValue:{value:'An "empty" or "falsy" value of whatever type is given in the schema.'},description:"The data to display in the treema. Should conform to the schema given.",name:"data",required:!0,type:{name:"any"}},schema:{defaultValue:{value:"{} (any JSON object allowed)"},description:"The schema to use to validate the data. Treema will use this to determine\nhow to construct the UI, and how the data may be edited\n@see https://json-schema.org/understanding-json-schema/",name:"schema",required:!0,type:{name:"TreemaSupportedJsonSchema"}},schemaLib:{defaultValue:{value:"A noop version - no validation, no error messages"},description:'A schema library instance to use to validate the data.\nThere are [many JavaScript libraries](https://json-schema.org/implementations.html#validators)\nthat support various drafts of the JSON Schema spec.\nWrap your chosen library to match the TypeScript interface "SchemaLib".\nGenerally you should initialize the library, which may provide options\nwhich will affect the behavior of Treema. Treema also depends on this library\nto provide error messages.\n\nSee wrapTv4 and wrapAjv for examples.',name:"schemaLib",required:!1,type:{name:"TreemaWrappedSchemaLib"}},onEvent:{defaultValue:null,description:"A callback for when the user interacts with the treema.\n\nSupported events:\n- `change_select_event`: when the user selects a node. Includes `path` in the event.",name:"onEvent",required:!1,type:{name:"TreemaEventHandler"}},definitions:{defaultValue:{value:"The default definitions, which cover all JSON Schema types and a few advanced examples."},description:'Custom Treema node definitions. Use these to customize how Treema renders data\nof certain types. Treema will first see if there\'s a match for the "format" on the\ndata\'s schema, then will match its "type". If no match is found, Treema will use the\ndefault node definitions, keying off what type the data currently is.\n\nSee [TreemaTypeDefinition](https://github.com/sderickson/react-treema/blob/4923128ed24089d8677b11608cbe9afbfde1c51b/src/Treema/types.ts#L319)\nfor documentation on definitions.',name:"definitions",required:!1,type:{name:"TreemaTypeDefinition[]"}},initOpen:{defaultValue:{value:"All levels are open by default"},description:"The number of levels deep to open the tree by default.",name:"initOpen",required:!1,type:{name:"number"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/Treema/TreemaRoot.tsx#TreemaRoot"]={docgenInfo:TreemaRoot.__docgenInfo,name:"TreemaRoot",path:"src/Treema/TreemaRoot.tsx#TreemaRoot"})}catch(__react_docgen_typescript_loader_error){}},"./src/Treema/context.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{n:()=>TreemaContext});var _utils__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/Treema/utils.ts"),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/index.js");const defaultContextData={state:{data:{},schemaLib:_utils__WEBPACK_IMPORTED_MODULE_0__.noopLib,rootSchema:{type:"null"},closed:{},definitions:{},settings:{},workingSchemaChoices:{}},dispatch:()=>{},editRefs:[]},TreemaContext=(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(defaultContextData)},"./src/Treema/definitions/hooks.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{S:()=>useTreemaEditRef,f:()=>useTreemaKeyboardEvent});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_context__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/Treema/context.ts");const useTreemaKeyboardEvent=callback=>{const{keyboardCallbackRef}=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__.n);(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>(keyboardCallbackRef&&(keyboardCallbackRef.current=callback),()=>{keyboardCallbackRef&&(keyboardCallbackRef.current=void 0)})),[keyboardCallbackRef,callback])},useTreemaEditRef=()=>{const{editRefs}=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__.n),editRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>(editRefs.push(editRef),()=>{const refIndex=editRefs.indexOf(editRef);refIndex>=0&&editRefs.splice(refIndex,1)})),[editRef,editRefs]),editRef};try{useTreemaKeyboardEvent.displayName="useTreemaKeyboardEvent",useTreemaKeyboardEvent.__docgenInfo={description:"Use this in `edit` for definitions to register a callback for keyboard events.\nReturn `false` to prevent Treema's default handling of that event. This is useful\nfor example to cancel moving to the next node, such as when editing multiple\nlines where tab and enter are normally used. This can also be used to implement\ncustom errors where navigation is prevented until an error is fixed.",displayName:"useTreemaKeyboardEvent",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/Treema/definitions/hooks.tsx#useTreemaKeyboardEvent"]={docgenInfo:useTreemaKeyboardEvent.__docgenInfo,name:"useTreemaKeyboardEvent",path:"src/Treema/definitions/hooks.tsx#useTreemaKeyboardEvent"})}catch(__react_docgen_typescript_loader_error){}try{useTreemaEditRef.displayName="useTreemaEditRef",useTreemaEditRef.__docgenInfo={description:'Provides a ref which should be used for the input element rendered. This is so\nthat Treema can manage focus and blur events.\n\nCurrently Treema only supports one input per "node".',displayName:"useTreemaEditRef",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/Treema/definitions/hooks.tsx#useTreemaEditRef"]={docgenInfo:useTreemaEditRef.__docgenInfo,name:"useTreemaEditRef",path:"src/Treema/definitions/hooks.tsx#useTreemaEditRef"})}catch(__react_docgen_typescript_loader_error){}},"./src/Treema/utils.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{AH:()=>getValueForRequiredType,Eu:()=>getJsonPointerDepth,Fc:()=>getChildSchema,Ke:()=>chooseWorkingSchema,Ms:()=>populateRequireds,Tq:()=>getJsonPointerLastChild,VK:()=>getParentJsonPointer,_V:()=>joinJsonPointers,_p:()=>walk,cD:()=>getNoopLib,d9:()=>clone,oL:()=>getType,qD:()=>splitJsonPointer,rQ:()=>wrapAjv,tk:()=>wrapTv4,wg:()=>getChildWorkingSchema,zL:()=>buildWorkingSchemas});class NoopLib{constructor(){this._schemas={},this._schemas={}}validateMultiple(d,s){return{valid:!0,errors:[],missing:[]}}getSchemaRef(id){return this._schemas[id]}addSchema(schema,id){this._schemas[id]=schema}}const getNoopLib=()=>new NoopLib,wrapTv4=tv4=>({validateMultiple:(data,schema)=>{let tv4Result=tv4.validateMultiple(data,schema);return{valid:tv4Result.valid,missing:tv4Result.missing,errors:tv4Result.errors.map((error=>({id:error.code,message:error.message,dataPath:error.dataPath})))}},getSchemaRef:ref=>tv4.getSchema(ref),addSchema:(schema,id)=>{id?tv4.addSchema(id,schema):tv4.addSchema(schema)}}),wrapAjv=ajv=>(ajv.addKeyword("displayProperty"),{validateMultiple:(data,schema)=>({valid:ajv.validate(schema,data),missing:[],errors:(ajv.errors||[]).map((error=>({id:error.keyword,message:error.message,dataPath:error.instancePath})))}),getSchemaRef:ref=>ajv.getSchema(ref),addSchema:(schema,id)=>{ajv.addSchema(schema,id)}}),walk=(data,schema,lib,callback,path)=>{const workingSchemas=buildWorkingSchemas(schema,lib);let workingSchema=chooseWorkingSchema(data,workingSchemas,lib);const schemaOverride=callback({path:path||"",data,schema:workingSchema,possibleSchemas:workingSchemas});schemaOverride&&(workingSchema=schemaOverride);const dataType=getType(data);if(["array","object"].includes(dataType)){const f=(key,value)=>{value=data[key];const childPath=joinJsonPointers(path||"",key.toString());let childSchema=getChildSchema(key,workingSchema);walk(value,childSchema,lib,callback,childPath)};"array"===dataType?data.forEach(((value,index)=>{f(index,value)})):Object.entries(data).forEach((entry=>{f(entry[0],entry[1])}))}},getType=function(){const classToType={},ref="Boolean Number String Function Array Date RegExp Undefined Null".split(" ");for(let i=0,len=ref.length;i<len;i++){let name=ref[i];classToType["[object "+name+"]"]=name.toLowerCase()}return function(obj){var strType;return strType=Object.prototype.toString.call(obj),classToType[strType]||"object"}}(),getJsonType=data=>{switch(getType(data)){case"boolean":return"boolean";case"number":return"number";case"string":return"string";case"array":return"array";case"object":return"object";case"null":return"null"}},buildWorkingSchemas=(schema,lib)=>{const givenSchema=resolveReference(schema,lib);if(!givenSchema.allOf&&!givenSchema.anyOf&&!givenSchema.oneOf)return spreadTypes(givenSchema);let baseSchema=cloneSchema(givenSchema);const allOf=baseSchema.allOf,anyOf=baseSchema.anyOf,oneOf=baseSchema.oneOf;if(delete baseSchema.allOf,delete baseSchema.anyOf,delete baseSchema.oneOf,allOf)for(const schema of allOf)baseSchema=combineSchemas(baseSchema,resolveReference(schema,lib));let singularSchemas=[];anyOf&&(singularSchemas=singularSchemas.concat(anyOf)),oneOf&&(singularSchemas=singularSchemas.concat(oneOf));let workingSchemas=[];for(let singularSchema of singularSchemas){singularSchema=resolveReference(singularSchema,lib);let newBase=cloneSchema(baseSchema);newBase=combineSchemas(newBase,singularSchema),workingSchemas=workingSchemas.concat(spreadTypes(newBase))}return 0===workingSchemas.length&&(workingSchemas=spreadTypes(baseSchema)),workingSchemas},baseTypes=["string","boolean","number","array","object","null"],spreadTypes=schema=>{const workingSchemas=[];if(void 0===schema.type)baseTypes.forEach((type=>{workingSchemas.push({...schema,type})}));else{if("string"===getType(schema.type))return[schema];schema.type.forEach((type=>{workingSchemas.push({...schema,type})}))}return workingSchemas},chooseWorkingSchema=(data,workingSchemas,lib)=>{if(1===workingSchemas.length)return workingSchemas[0];let bestNumErrors=1/0,bestSchema=workingSchemas[0];for(const schema of workingSchemas){const result=lib.validateMultiple(data,schema);if(result.valid&&getJsonType(data)===schema.type)return schema;bestNumErrors>result.errors.length&&(bestSchema=schema,bestNumErrors=result.errors.length)}return bestSchema},getChildSchema=(key,schema)=>{if("string"==typeof key){for(const[childKey,childSchema]of Object.entries(schema.properties||{}))if(childKey===key)return childSchema;for(const[childKey,childSchema]of Object.entries(schema.patternProperties||{}))if(key.match(new RegExp(childKey)))return childSchema;if("object"==typeof schema.additionalProperties)return schema.additionalProperties}if("number"==typeof key&&schema.items)if(Array.isArray(schema.items)){if(key<schema.items.length)return schema.items[key];if(schema.additionalItems)return schema.additionalItems}else if(schema.items)return schema.items;return{}},getChildWorkingSchema=(key,schema,lib)=>{const childSchema=getChildSchema(key,schema),workingSchemas=buildWorkingSchemas(childSchema,lib);return chooseWorkingSchema(void 0,workingSchemas,lib)},resolveReference=(schema,lib)=>{if(schema.$ref){const resolved=lib.getSchemaRef(schema.$ref);return resolved||(console.warn("could not resolve reference",schema.$ref),{})}return schema},cloneSchema=schema=>Object.assign({},schema),combineSchemas=(baseSchema,schema)=>{const result=Object.assign({},baseSchema,schema);if(schema.properties&&baseSchema.properties){result.properties=Object.assign({},baseSchema.properties,schema.properties);for(const[key]of Object.entries(schema.properties))key in baseSchema.properties&&(result.properties[key]=combineSchemas(baseSchema.properties[key],schema.properties[key]))}return schema.required&&baseSchema.required&&(result.required=baseSchema.required.concat(schema.required)),result},clone=(data,options)=>{let result=data;const type=getType(data);if("object"===type&&(result={}),"array"===type&&(result=[]),["object","array"].includes(type)){const shallow=options&&options.shallow;for(const[key,value]of Object.entries(data))result[key]=shallow?value:clone(value,options)}return result},getValueForRequiredType=type=>{switch(type){case"boolean":return!1;case"number":case"integer":return 0;case"string":return"";case"array":return[];case"object":return{};case"null":return null}},populateRequireds=(givenData,schema,lib)=>{const returnData=clone(givenData)||{};return walk(returnData,schema,lib,(({data,schema})=>{if(schema.required&&"object"===getType(data))for(const key of schema.required)if(void 0===data[key])if(schema.default&&schema.default[key])data[key]=clone(schema.default[key]);else{const childSchema=getChildSchema(key,schema),workingSchemas=buildWorkingSchemas(childSchema,lib),workingSchema=chooseWorkingSchema(data,workingSchemas,lib),schemaDefault=workingSchema.default;if(schemaDefault)data[key]=clone(schemaDefault);else{const type=workingSchema.type;data[key]=getValueForRequiredType(type)}}})),returnData},splitJsonPointer=path=>path.split("/").slice(1),getJsonPointerLastChild=path=>{const parts=splitJsonPointer(path);return parts[parts.length-1]},joinJsonPointers=(...paths)=>("/"!==paths[paths.length-1][0]&&(paths[paths.length-1]="/"+paths[paths.length-1]),paths.join("")),getParentJsonPointer=path=>{const parts=path.split("/");return parts.pop(),parts.join("/")},getJsonPointerDepth=path=>splitJsonPointer(path).length},"./node_modules/css-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/Treema/base.scss":(module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js"),_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__),_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js"),___CSS_LOADER_EXPORT___=__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__)()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());___CSS_LOADER_EXPORT___.push([module.id,'.treema-target-of-copy-paste{transform:translateX(10px)}.treema-node{transition:.1s ease-in-out transform;user-select:none;-webkit-user-select:none;-moz-user-select:none;position:relative;font-family:"Helvetica Neue","Helvetica","Arial",sans-serif;clear:both;border-bottom:1px solid #ccc;font-size:13px;cursor:pointer}.treema-node.treema-root>.treema-row{border-bottom:1px solid #000}.treema-node.treema-root>.treema-row>.treema-key{font-weight:bold}.treema-node.treema-root>.treema-row .treema-type-select,.treema-node.treema-root>.treema-row>.treema-value{display:none}.treema-node.treema-root>.treema-children,.treema-node.treema-root>.treema-add-child{margin-left:0;left:0}.treema-node.treema-open>.treema-children{padding-top:1px}.treema-node.treema-root{outline:none}.treema-node input,.treema-node select{font-size:13px;font-family:"Helvetica Neue","Helvetica","Arial",sans-serif}.treema-node input{margin:-3px 0;width:200px}.treema-node .treema-new-prop{margin:2px 15px 10px}.treema-type-select,.treema-schema-select{margin-right:5px}.treema-children{margin-left:15px;clear:both}.treema-add-child{background-color:#eef;border:1px solid #aaf;cursor:pointer;display:inline-block;margin:3px 0 10px;padding:0 5px;font-weight:bold;position:relative;left:16px;font-size:10px}.treema-add-child:hover{background-color:#ccf}.treema-add-child:focus{box-shadow:0 0 3px #aaf}.treema-full>.treema-children>.treema-add-child{display:none}.treema-full.treema-open>.treema-children{margin-bottom:5px}.treema-row{padding:2px 3px 2px 3px;display:flex}.treema-value{cursor:text;display:block;flex-grow:1;max-width:100%;min-width:50px}.treema-key{color:#5353ac;display:block;cursor:pointer;margin-right:5px}.treema-backdrop{position:absolute;top:0;left:0;height:25px;background-color:rgba(64,128,255,0);pointer-events:none;width:100%;cursor:pointer}.treema-description{float:right;opacity:.8;font-size:11px;line-height:13px;min-width:200px;text-align:right;display:none}.treema-selected>.treema-row>.treema-description{display:inline}.treema-edit+.treema-description{display:inline}.treema-selected>.treema-row{background-color:rgba(64,128,255,.25)}.treema-error{color:darkred;margin:2px 10px}.treema-has-error{background-color:#ffb6c1;border:1px solid darkred}.treema-temp-error{background-color:#ffb6c1;padding:2px 3px;color:darkred;margin:0 5px;border:1px solid darkred}.treema-toggle{width:0;height:0;opacity:.7;position:absolute}.treema-closed>.treema-toggle{border-top:6px solid rgba(0,0,0,0);border-bottom:6px solid rgba(0,0,0,0);border-left:8px solid #666;top:2px;left:-9px}.treema-open>.treema-toggle{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:8px solid #666;top:4px;left:-12px}.treema-clearfix:after{content:".";display:block;height:0;clear:both;visibility:hidden}.treema-shortened>.treema-row{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.treema-multiline{width:inherit}.treema-clipboard-container{position:fixed;left:0;top:0;width:0;height:0;z-index:100;display:none;opacity:0}.treema-clipboard-container .treema-clipboard{width:1px;height:1px;padding:0}.treema-filter-hidden{display:none}.treema-default-stub{opacity:.7}',"",{version:3,sources:["webpack://./src/Treema/base.scss","webpack://./src/Treema/_variables.scss"],names:[],mappings:"AAEA,6BACE,0BAAA,CAEF,aACE,oCAAA,CACA,gBAAA,CACA,wBAAA,CACA,qBAAA,CACA,iBAAA,CACA,2DAAA,CACA,UAAA,CACA,4BAAA,CACA,cCdS,CDeT,cAAA,CAGA,qCACE,4BAAA,CAEF,iDACE,gBAAA,CAEF,4GAEE,YAAA,CAIF,qFAEE,aAAA,CACA,MAAA,CAGF,0CACE,eAAA,CAEF,yBAEE,YAAA,CAEF,uCAEE,cC7CO,CD8CP,2DAAA,CAEF,mBACE,aAAA,CACA,WAAA,CAEF,8BACE,oBAAA,CAGJ,0CAEE,gBAAA,CAEF,iBACE,gBAAA,CACA,UAAA,CAEF,kBACE,qBAAA,CACA,qBAAA,CACA,cAAA,CACA,oBAAA,CACA,iBAAA,CACA,aAAA,CACA,gBAAA,CACA,iBAAA,CACA,SAAA,CACA,cAAA,CAEA,wBACE,qBAAA,CAGF,wBACE,uBAAA,CAGJ,gDACE,YAAA,CAEF,0CACE,iBAAA,CAEF,YACE,uBAAA,CACA,YAAA,CAEF,cACE,WAAA,CACA,aAAA,CACA,WAAA,CACA,cAAA,CACA,cAAA,CAEF,YACE,aAAA,CACA,aAAA,CACA,cAAA,CACA,gBAAA,CAEF,iBACE,iBAAA,CACA,KAAA,CACA,MAAA,CACA,WAAA,CACA,mCAAA,CACA,mBAAA,CACA,UAAA,CACA,cAAA,CAEF,oBACE,WAAA,CACA,UAAA,CACA,cAAA,CACA,gBCzHS,CD0HT,eAAA,CACA,gBAAA,CACA,YAAA,CAEF,iDACE,cAAA,CAEF,iCACE,cAAA,CAEF,6BACE,qCClIc,CDsIhB,cACE,aAAA,CACA,eAAA,CAEF,kBACE,wBAAA,CACA,wBAAA,CAEF,mBACE,wBAAA,CACA,eAAA,CACA,aAAA,CACA,YAAA,CACA,wBAAA,CAKF,eACE,OAAA,CACA,QAAA,CACA,UAAA,CACA,iBAAA,CAEA,8BACE,kCAAA,CACA,qCAAA,CACA,0BAAA,CACA,OAAA,CACA,SAAA,CAEF,4BACE,mCAAA,CACA,oCAAA,CACA,yBAAA,CACA,OAAA,CACA,UAAA,CAIJ,uBACE,WAAA,CACA,aAAA,CACA,QAAA,CACA,UAAA,CACA,iBAAA,CAEF,8BACE,eAAA,CACA,sBAAA,CACA,kBAAA,CAEF,kBACE,aAAA,CAGF,4BACE,cAAA,CACA,MAAA,CACA,KAAA,CACA,OAAA,CACA,QAAA,CACA,WAAA,CACA,YAAA,CACA,SAAA,CAEA,8CACE,SAAA,CACA,UAAA,CACA,SAAA,CAGJ,sBACE,YAAA,CAEF,qBACE,UAAA",sourcesContent:["@import 'variables';\n\n.treema-target-of-copy-paste {\n  transform: translateX(10px);\n}\n.treema-node {\n  transition: 0.1s ease-in-out transform;\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  position: relative;\n  font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;\n  clear: both;\n  border-bottom: 1px solid #ccc;\n  font-size: $fontSize;\n  cursor: pointer;\n\n  // Treema Root elem should display an emphasized title (and not much else)\n  &.treema-root > .treema-row {\n    border-bottom: 1px solid black;\n  }\n  &.treema-root > .treema-row > .treema-key {\n    font-weight: bold;\n  }\n  &.treema-root > .treema-row .treema-type-select,\n  &.treema-root > .treema-row > .treema-value {\n    display: none;\n  }\n\n  // Treema root elements and children should be aligned along the left edge\n  &.treema-root > .treema-children,\n  &.treema-root > .treema-add-child {\n    margin-left: 0;\n    left: 0;\n  }\n\n  &.treema-open > .treema-children {\n    padding-top: 1px;\n  }\n  &.treema-root {\n    // remove this to debug keyboard focus\n    outline: none;\n  }\n  input,\n  select {\n    font-size: $fontSize;\n    font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;\n  }\n  input {\n    margin: -3px 0;\n    width: 200px;\n  }\n  .treema-new-prop {\n    margin: 2px 15px 10px;\n  }\n}\n.treema-type-select,\n.treema-schema-select {\n  margin-right: 5px;\n}\n.treema-children {\n  margin-left: 15px;\n  clear: both;\n}\n.treema-add-child {\n  background-color: #eef;\n  border: 1px solid #aaf;\n  cursor: pointer;\n  display: inline-block;\n  margin: 3px 0 10px;\n  padding: 0 5px;\n  font-weight: bold;\n  position: relative;\n  left: 16px;\n  font-size: 10px;\n\n  &:hover {\n    background-color: #ccf;\n  }\n\n  &:focus {\n    box-shadow: 0 0 3px #aaf;\n  }\n}\n.treema-full > .treema-children > .treema-add-child {\n  display: none;\n}\n.treema-full.treema-open > .treema-children {\n  margin-bottom: 5px;\n}\n.treema-row {\n  padding: $rowInternalVerticalPadding 3px $rowInternalVerticalPadding 3px;\n  display: flex;\n}\n.treema-value {\n  cursor: text;\n  display: block;\n  flex-grow: 1;\n  max-width: 100%;\n  min-width: 50px;\n}\n.treema-key {\n  color: #5353ac;\n  display: block;\n  cursor: pointer;\n  margin-right: 5px;\n}\n.treema-backdrop {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: $fontSize + (2 * $rowVerticalPadding) + (2 * $rowInternalVerticalPadding) + 2px;\n  background-color: rgba(64, 128, 255, 0);\n  pointer-events: none;\n  width: 100%;\n  cursor: pointer;\n}\n.treema-description {\n  float: right;\n  opacity: 0.8;\n  font-size: $fontSize - 2;\n  line-height: $fontSize;\n  min-width: 200px;\n  text-align: right;\n  display: none;\n}\n.treema-selected > .treema-row > .treema-description {\n  display: inline;\n}\n.treema-edit + .treema-description {\n  display: inline;\n}\n.treema-selected > .treema-row {\n  background-color: $selectedColor;\n}\n// Errors\n\n.treema-error {\n  color: #8b0000;\n  margin: $rowInternalVerticalPadding 10px;\n}\n.treema-has-error {\n  background-color: #ffb6c1;\n  border: 1px solid #8b0000;\n}\n.treema-temp-error {\n  background-color: #ffb6c1;\n  padding: $rowInternalVerticalPadding 3px;\n  color: #8b0000;\n  margin: 0 5px;\n  border: 1px solid #8b0000;\n}\n// Collection toggle\n// http://css-tricks.com/snippets/css/css-triangle/\n\n.treema-toggle {\n  width: 0;\n  height: 0;\n  opacity: 0.7;\n  position: absolute;\n\n  .treema-closed > & {\n    border-top: 6px solid transparent;\n    border-bottom: 6px solid transparent;\n    border-left: 8px solid $triangleColor;\n    top: 2px;\n    left: -9px;\n  }\n  .treema-open > & {\n    border-left: 6px solid transparent;\n    border-right: 6px solid transparent;\n    border-top: 8px solid $triangleColor;\n    top: 4px;\n    left: -12px;\n  }\n  // http://www.positioniseverything.net/easyclearing.html\n}\n.treema-clearfix:after {\n  content: '.';\n  display: block;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n.treema-shortened > .treema-row {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.treema-multiline {\n  width: inherit;\n}\n// Amazing invisible clipboard magic http://stackoverflow.com/questions/17527870/how-does-trello-access-the-users-clipboard\n.treema-clipboard-container {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  z-index: 100;\n  display: none;\n  opacity: 0;\n\n  .treema-clipboard {\n    width: 1px;\n    height: 1px;\n    padding: 0;\n  }\n}\n.treema-filter-hidden {\n  display: none;\n}\n.treema-default-stub {\n  opacity: 0.7;\n}\n","$fontSize: 13px;\n$rowVerticalPadding: 3px;\n$rowInternalVerticalPadding: 2px;\n$selectedColor: rgba(64, 128, 255, 0.25);\n$triangleColor: #666;\n"],sourceRoot:""}]);const __WEBPACK_DEFAULT_EXPORT__=___CSS_LOADER_EXPORT___},"./node_modules/css-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/Treema/definitions/core.scss":(module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js"),_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__),_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js"),___CSS_LOADER_EXPORT___=__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__)()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());___CSS_LOADER_EXPORT___.push([module.id,".treema-string{color:#998500}.treema-number{color:#699900}.treema-null{color:#524059;font-weight:bold}.treema-array{color:#009905;cursor:row-resize}.treema-object{color:#008799;cursor:row-resize}.treema-boolean{color:#140099;cursor:pointer}.treema-boolean.treema-edit{background-color:rgba(64,128,255,.25)}.treema-boolean input{opacity:0}.treema-boolean:hover+.treema-description{display:inline}","",{version:3,sources:["webpack://./src/Treema/definitions/core.scss","webpack://./src/Treema/_variables.scss"],names:[],mappings:"AAEA,eACE,aAAA,CAEF,eACE,aAAA,CAEF,aACE,aAAA,CACA,gBAAA,CAEF,cACE,aAAA,CACA,iBAAA,CAEF,eACE,aAAA,CACA,iBAAA,CAEF,gBACE,aAAA,CACA,cAAA,CACA,4BACE,qCCrBY,CDuBd,sBACE,SAAA,CAEF,0CACE,cAAA",sourcesContent:["@import '../variables';\n\n.treema-string {\n  color: #998500;\n}\n.treema-number {\n  color: #699900;\n}\n.treema-null {\n  color: #524059;\n  font-weight: bold;\n}\n.treema-array {\n  color: #009905;\n  cursor: row-resize;\n}\n.treema-object {\n  color: #008799;\n  cursor: row-resize;\n}\n.treema-boolean {\n  color: #140099;\n  cursor: pointer;\n  &.treema-edit {\n    background-color: $selectedColor;\n  }\n  input {\n    opacity: 0; // hacky way to get tab selection and keyboard inputs to work;\n  }\n  &:hover + .treema-description {\n    display: inline;\n  }\n}\n","$fontSize: 13px;\n$rowVerticalPadding: 3px;\n$rowInternalVerticalPadding: 2px;\n$selectedColor: rgba(64, 128, 255, 0.25);\n$triangleColor: #666;\n"],sourceRoot:""}]);const __WEBPACK_DEFAULT_EXPORT__=___CSS_LOADER_EXPORT___}}]);